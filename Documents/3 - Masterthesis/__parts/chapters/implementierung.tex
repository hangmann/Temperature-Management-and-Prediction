%!TEX root = /Users/nphs/Dropbox/0-Bachelor/2012-BA-Cioran/02-Arbeit/BA-Cioran.tex
\chapter{Implementierung der Android Applikation}
\label{ch:implementierung}
Dieses Kapitel gibt einen Überblick über die Implementierung von \emph{ginkgo mobile}. Im Abschnitt \ref{sec:allgemein} werden weitere wichtige Funktionen des Betriebssystems genannt und beschrieben in welcher Form sie in der Applikation Verwendung finden. Die von \emph{iosched} übernommenen Komponenten werden im Abschnitt \ref{sec:ioschedimp} aufgezählt. Abschließend wird die Implementierung der eigentlichen Applikation und die dabei entstandenen Probleme thematisiert. 
\section{Allgemeines zu Android}
\label{sec:allgemein}
\subsection{Callback Methoden eines Fragments}
Ein Fragment kann als eine Art \emph{Sub-Activity} angesehen werden. Es besitzt einen eigenen Lifecycle indem verschiedene \emph{Callback} Methoden durch das Betriebssystem ausgeführt werden (siehe Abbildung \ref{pic:callback}). Diese sind zu den Activity \emph{Callback} Methoden fast identisch und werden direkt von ihnen beeinflusst [\cite{Googlec}]. Sobald also eine Activity beendet wird, werden die beinhaltenden Fragments auch beendet. Die wichtigsten \emph{Callback} Methoden werden im Folgenden nach \cite{Googlec} beschrieben.
\begin{figure}[!h]
	\includegraphics[scale=0.65]{__pics/android/fragment_lifecycle}
	\caption{Die Callback-Methoden eines Fragment nach \cite{Googlec}.}
	\label{pic:callback}
\end{figure}
\begin{itemize}
	\item\textbf{onCreate()}
	
	Diese Methode wird aufgerufen sobald das Fragment erstellt wird. Dabei sollen alle wichtigen Komponenten initialisiert werden.
	\clearpage
	\item \textbf{onCreateView()}
	
	Falls das Fragment ein \ac{UI} bietet, müssen die \emph{Views} innerhalb dieser Methode erstellt werden.
	\item \textbf{onPause()}
	
	Das Fragment wird möglicherweise geschlossen. Wichtige Änderungen müssen gespeichert werden, sodass diese wiederhergestellt werden sobald das Fragment erneut geladen wird.
	
\end{itemize}

\subsection{Oberfläche}
Um das \ac{UI} einer Activity oder eines Fragments zu erstellen, kann das Layout der einzelnen \emph{ViewGroups} und \emph{Views} in \ac{XML} Dateien definiert werden oder direkt im Programmcode. Das Verfahren über die \ac{XML} Datei hat jedoch den Vorteil, dass die Darstellung von den Programmabläufen getrennt wird. Dadurch wird eine bessere Übersicht geboten. Des Weiteren beinhalten die \ac{ADT} einen \ac{UI} Editor, der diese Prozedur erleichtert und Layouts als \ac{XML} abspeichert, sodass sie nicht per Hand geschrieben werden müssen. 

\subsection{ListFragment}
\label{sec:listfragment}
Durch ein \emph{ListFragment} lassen sich Daten als Elemente einer Liste leicht darstellen. Dieses Fragment beinhaltet eine \emph{ListView} (siehe \cite{Messerschmidt2011}), die dessen Elemente aus verschiedenen Quellen, wie zum Beispiel Arrays, beziehen kann [\cite{Androidc}]. Das Layout einer Zeile lässt sich ebenfalls per \ac{XML} beschreiben und das Abbilden der Daten auf die verschiedenen \emph{Views} wird in \emph{ginkgo mobile} über Subklassen der Android Klasse \emph{ArrayAdapter} realisiert. Dafür muss der jeweilige Adapter der \emph{ListView} über die \emph{setListAdapter} Methode übergeben werden.

\emph{ListFragments} werden zum Beispiel für die Anzeige eines \emph{ActivityStreams} verwendet.

\subsection{Speicherung von Daten}
Um \graffito{SharedPreferences} Daten persistent auf einem Endgerät abspeichern zu können, bietet Android die Klasse \emph{SharedPreferences} an. Dadurch kann der Wert eines primitiven Datentyps auf einen Schlüssel abgebildet werden. Diese Funktion wird für das Speichern des \emph{Access Tokens} verwendet.

\subsection{Nebenläufigkeit}
\label{sec:asynctask}
Für jede gestartete Android Applikation wird vom Betriebssystem ein Thread namens \emph{UI Thread} erstellt [\cite{Androidb}]. Er ist für die Anzeige der Views (siehe \ref{sec:androidprog}) verantwortlich und reagiert auf Benutzerinteraktionen. Wird dieser Thread aber durch lang andauernde Operationen wie \ac{IO} (z.B. Netzwerkkommunikation) oder lang andauernde Berechnungen blockiert, bekommt der Benutzer eine \ac{ANR} Meldung gezeigt und erhält dadurch die Möglichkeit das Programm zu beenden. Um das zu verhindern, müssen langandauernde Funktionen in andere Threads verlagert werden. Die von Java bereitgestellte \emph{Thread} Klasse ist eine Möglichkeit. Sie ist aber nicht in der Lage die Oberfläche zu aktualisieren [\cite{Androidb}].

Um \graffito{AsyncTask} dieses Problem zu umgehen, bietet sich die Android Klasse \emph{AsyncTask} an. Dafür muss eine neue Klasse geschrieben werden, die von \emph{AsyncTask} erbt und bestimmte Methoden überschreibt. Die langandauernde Funktion muss in der \emph{doInBackground} Methode implementiert und das Ergebnis in der \emph{onPostExecute} Methode verarbeitet werden. Um die Erstellung von Threads kümmert sich die Klasse selbst [\cite{Androidb}].

Durch dieses Konzept werden die für die Kommunikation mit der \ac{API} benötigten \emph{GET} und \emph{POST} Methoden als Threads realisiert (siehe Abschnitt \ref{sec:apiaufrufimp}).

\textbf{Implementierte AsyncTask Unterklassen von ginkgo mobile}
\begin{itemize}
	\item \emph{GetTask}
	
	Diese Klasse ist für die \emph{GET} Aufrufe von Ressourcen an die \ac{API} zuständig.
	\clearpage
	\item \emph{PostTask}
	
	Dementsprechend können über die \emph{PostTask} Klasse über die \emph{POST} Operation serverseitig neue Ressourcen angelegt oder editiert werden.
	
	\item \emph{GetAvatars}
	
	Durch diese Klasse können Avatare von Events und Nutzern geladen werden.
\end{itemize}

\subsection{Handler}
Eine Möglichkeit einen Callback in Android zu realisieren besteht durch die von Android bereitgestellte \emph{Handler} Klasse. Dadurch können Messages\footnote{Die Klasse \emph{Message} gehört zum Android \ac{SDK}. Eine \emph{Message} kann ein weiteres Java Objekt beinhalten [\cite{Androide}].} zwischen Komponenten versendet werden. Definiert werden sie in der Komponente die das Ergebnis erhalten soll. Weiteren Komponenten kann der \emph{Handler} als Parameter übergeben werden. Sobald diese das Ergebnis vorliegen haben, können sie über die Methode \emph{sendMessage(Message m)} eine Nachricht schicken, die automatisch vom anderen Handler empfangen und abgearbeitet wird.

\section{iosched}
\label{sec:ioschedimp}
Die von \emph{iosched} gegebenen Funktionen dienen der Darstellung von sich nicht ändernden Informationen. Dadurch werden alle notwendigen Daten während der Installation auf dem Endgerät abgespeichert. Dadurch ist keine Kommunikation und vor allem keine Authentifizierung mit einem Server notwendig. Des Weiteren besteht das Programm aus verschiedenen Activitys und Fragments. Das Konzept von \emph{ginkgo mobile} sieht jedoch eine Activity mit mehreren Fragments vor. Auf Grund der verschiedenen Anwendungsgebiete und Funktionalitäten, wird \emph{ginkgo mobile}, bis auf Teile des von \emph{iosched} gelieferten \emph{DashboardFragment}, von Grund auf neu entwickelt.

\section{Login per OAuth 2.0}
\label{sec:oauthimp}
Der Login Prozess der Applikation gegenüber der \ac{API} besteht aus dem Zusammenspiel der \emph{LoginActivity} und der Klasse \emph{Ginkgoweb}. Grafisch wird dieser Ablauf in Abbildung \ref{pic:login_activityd} dargestellt. Die \emph{LoginActivity} beginnt damit einen \emph{Handler} zu initialisieren, die \emph{SharedPreferences} zu laden und ein Objekt der Hilfsklasse \emph{Ginkgoweb} zu erstellen. Wenn das Tablet über eine Verbindung zum Internet verfügt, wird das \emph{Ginkgoweb} Objekt dazu veranlasst zu überprüfen, ob ein \emph{Acces Token} in den \emph{SharedPreferences} gespeichert ist. Ist \graffito{Gültiges Access Token vorhanden} dies der Fall, wird in einem neuen Thread über eine \ac{HTTP} \emph{GET} Anfrage an die API geprüft, ob dieses Access Token gültig ist. Über den \emph{Handler} wird das Ergebnis an die \emph{LoginActivity} weitergeleitet, die bei einem gültigen \emph{Token} die \emph{DashActivity} (siehe \ref{sec:ginkgomobilekomponenten}) startet.

Falls \graffito{Kein gültiges Access Token vorhanden} kein \emph{Access Token} vorhanden ist oder es seine Gültigkeit verloren hat, muss ein neues erstellt werden. Die allgemeine Vorgehensweise dazu wurde im Abschnitt \ref{sec:oauth} erklärt. Die Implementierung dazu folgt über die von Android bereitgestellte \emph{WebView}\footnote{Durch eine WebView lässt sich ein Browser innerhalb einer Android Applikation anzeigen.} Klasse. Nachdem der Nutzer seine persönlichen Daten abgeschickt hat, wird der \emph{Authorization Code} aus der \emph{Redirect}-\ac{URL} ausgelesen und über eine \emph{GET} Anfrage an die \ac{API} gegen das \emph{Access Token} getauscht.

Das \emph{Access Token} wird persistent in den SharedPreferences gespeichert und anschließend wird die \emph{DashActivity} gestartet. 

	\begin{figure}[h]
		\includegraphics[width=\textwidth]{__pics/diagramme/login_activityd}
		\caption{Der Loginprozess als Aktivitätsdiagramm}
		\label{pic:login_activityd}
	\end{figure}
	
\section{Modellierung der Modellklassen anhand der API Ressourcen}
Die von der \ac{API} als \ac{JSON} gelieferten Pakete haben je nach Ressource einen bestimmten Aufbau. Um solch ein Paket von Gson zu \emph{deserialisieren} (siehe \ref{sec:gson}) werden Modellklassen anhand des Aufbaus der Ressourcen erstellt. Diese Klassen beinhalten die Felder der Ressource als Attribute und den Namen als Klassennamen.

\section{API Aufrufe im REST Stil und deren Verarbeitung durch den JsonHelper}
\label{sec:apiaufrufimp}
Alle \ac{API} Aufrufe werden über die Klasse \emph{JsonHelper} getätigt. Nach einem erfolgreichen Login (siehe \ref{sec:oauthimp}) wird ein Objekt der Klasse \emph{JsonHelper} erstellt und die \emph{Entry Points} der \ac{API} werden innerhalb einer \emph{HashMap} im \emph{JsonHelper} gespeichert. Da jedes Fragment und die \emph{DashActivity} Anfragen an den \emph{JsonHelper} stellen können, wurde die Klasse nach dem \emph{Singleton} Pattern kreiert. Dadurch lässt sich nur ein Objekt dieser Klasse erstellen. Das hat den Vorteil, dass keine Betriebssystem Ressourcen durch eine neue Initialisierung verschwendet werden und dass die \emph{Entry Points} nicht bei jeder Anfrage neu geladen werden müssen. Da die Namen der \emph{EntryPoints} festgelegt sind, kann über die \emph{HashMap} die jeweilige \ac{URL} der Ressource nachgeschlagen werden. 

Über \graffito{GET JSON} die \emph{GetJson()} Methode des \emph{JsonHelper} (siehe Listing \ref{lst:getjson}) wird das \ac{JSON} von der in den Parametern übergebenen \ac{URL} durch einen \emph{GetTask} (siehe Abschnitt \ref{sec:asynctask}) geladen. Das Interface \emph{ResponseCallback} muss von der aufrufenden Klasse implementiert werden, sodass das Ergebnis der Methode dem Aufrufer übergeben werden kann. Durch den \emph{embed json} Parameter wird die \ac{API} dazu veranlasst Ressourcen, die innerhalb einer Liste eingebettet sind, direkt mit in das \ac{JSON} Paket zu schreiben. Dies bietet gegenüber dem Standardverhalten, welches nur die \ac{URL} der Ressource in das \ac{JSON} Paket schreibt, den Vorteil, dass keine weiteren \emph{GetTasks} für die einzelnen Elemente nötig sind.

Nachdem \graffito{Parse JSON}das \ac{JSON} Paket geladen wurde, wird der Aufrufer aufgefordert das Paket zu parsen. Dazu bietet die \emph{ginkgo mobile} Klasse \emph{JsonParser} statische Methoden für verschiedene Ressourcen an. Die jeweilige Methode bekommt das \ac{JSON} Paket als Parameter übergeben und \emph{deserialisiert} es mit der Hilfe von \emph{Gson}. Das daraus entstandene JAVA Objekt wird zurückgegeben und kann dann von dem Aufrufer verwendet werden.

\begin{lstlisting}[caption={Die getJson Methode der JsonHelper Klasse.}]
  ENTITY DFlipflop IS
    PORT(D,Clk: IN Bit;
         Q: 	OUT Bit);
  END DFlipflop;
  ARCHITECTURE Behav OF DFlipflop IS 
      CONSTANT T_Clk_Q: time := 4.23 ns;
  BEGIN 
      PROCESS
      BEGIN
         WAIT UNTIL Clk'EVENT AND Clk='1';
         Q <= D AFTER T_Clk_Q;
      END PROCESS;
  END Behav;
  
  \end{lstlisting}
\label{lst:getjson}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/diagramme/jsonget_activityd}
	\caption{JsonHelper ActivityDiag}
\end{figure}
	
\section{Das Dashboard}
\label{sec:dashboardimp}
Die \emph{DashActivity} ist für den Zusammenhalt der Applikation verantwortlich. Sie implementiert die Interfaces \emph{DashClickListener} und \emph{ResponseCallback}. Durch das \emph{DashClickListener} Interface wird sichergestellt, dass die Activity die notwendigen Funktionen zum Wechseln des Fragments bereitstellt, die vom \emph{DashboardFragment} benötigt werden. Durch einen Klick auf ein Icon innerhalb des \emph{Dashboardfragments} wird durch einen Callback an die Activity das anzuzeigende Fragment ausgetauscht. Dadurch bleibt die Kontrolle über die angezeigten Fragments bei der Activity. 

Bevor dem Nutzer die Kontrolle über die Applikation gegeben wird, wird der \emph{JsonHelper} dazu aufgefordert die \emph{EntryPoints} der \ac{API} zu laden, da sonst keine Kommunikation mit dieser möglich ist. 

Um \graffito{Fragments austauschen} das aktive Fragment auszutauschen, wird in der jeweiligen Activity Funktion ein neues Objekt des Zielfragments erstellt. Dieses wird der Methode \emph{changeRightFragment} als Parameter übergeben und durch die \emph{replace} Methode der \emph{FragmentTransaction} Klasse ausgetauscht. Das alte Fragment wird dabei auf den \emph{BackStack} gelegt, sodass durch das Betätigen der \emph{Zurück} Taste das alte Fragment angezeigt wird.

\begin{lstlisting}[caption={Die Methode zum ersetzen der Container View.}]
private void changeRightFragment(Fragment fragment) {
	FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
	ft.replace(R.id.rightfrag, fragment);
	// Add a transition effect
	ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);
	// Add the Fragment to the BackStack so it can be restored by
	// pressing the Back button
	ft.addToBackStack(null);
	ft.commit();
}
\end{lstlisting}
\label{lst:changefragment}
\clearpage
\begin{figure}[!h]
	\includegraphics[width=\textwidth]{__pics/diagramme/DashActivityNew}
	\caption{Die \emph{DashActivity} in Form eines Klassendiagramms.}
\end{figure}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/diagramme/changefrag_seqd}
	\caption{Dieses Sequenzdiagramm verdeutlicht den Ablauf der \emph{changeFragment} Methode.}
\end{figure}

\section{Die Fragments}
Alle in \emph{ginkgo mobile} verwendeten Fragments wurden nach einem Muster erstellt. Dabei werden in der \emph{onCreate} Methode über die \emph{JsonHelper} Klasse die Daten geladen, die für die Darstellung notwendig sind. Dies geschieht Asynchron, damit der \emph{UI Thread} nicht blockiert. Sobald die Daten geladen wurden, wird die \emph{onDataReceived} Methode ausgeführt und dadurch die notwendigen Daten geparsed und als Java Objekte in den Hauptspeicher gelegt. Daraufhin wird die Oberfläche aktualisiert, sodass die Daten angezeigt werden. Zum Schluss werden Icons durch die \emph{GetAvatars} Klasse asynchron nachgeladen. Demnach werden die wichtigsten Informationen zuerst angezeigt.
\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/diagramme/gettask_seqd}
	\caption{GetTask anhand des \emph{EventlistFragments}.}
\end{figure}

\section{Ein Activity Stream}
Ein \emph{Activity Stream} besteht aus einer Liste an verschiedenen Activities\footnote{In diesem Kontext ist nicht die Android Komponente \emph{Activity} gemeint. Hierbei handelt es sich um eine Ressource der \ac{API}.}. Eine Activity zeichnet sich nach \cite{Suntrup2012} aus einer Liste verschiedener Feldern aus (siehe Abbildung \ref{pic:activitystreamressource}):
\begin{enumerate}
	\item \textbf{Actor}
	
	Ein \emph{Actor} ist die Komponente einer Activity, die etwas ausgeführt hat. Dabei handelt es sich entweder um einen User, ein Event oder eine Submission.
	
	\item \textbf{Verb}
	
	Das \emph{Verb} gibt an was der \emph{Actor} getan hat.
	
	\item \textbf{Target} (Optional)
	
	Das \emph{Target} Feld wird bei Activities gebraucht, bei denen zusätzlich zum \emph{Actor} eine weitere Ressource beteiligt ist. Dabei handelt es sich ebenfalls um einen User, ein Event oder eine Submission.
	\item \textbf{Object} (Optional)
	
	Ein \emph{Object} wird bei zwei Activities gebraucht. Bei einem \emph{user posted status update} handelt es sich um ein Statusupdate eines Users in Form der Ressource \emph{Micropost}. Diese enthält die eigentliche Nachricht. Das Object der \emph{user updated description} Activity beinhaltet das von dem \emph{Actor} geänderte Feld.
\end{enumerate}
Der \emph{ActivityStream} findet sowohl im \emph{UserFragment} als auch im \emph{EventFragment} Verwendung. Sobald eins dieser Fragments gestartet wird, wird über den \emph{JsonHelper} der jeweilige ActivityStream geladen und in der \emph{ListView} (siehe \ref{sec:listfragment}) angezeigt. Um das \emph{Verb} gegen eine genaue Beschreibung auszutauschen, besitzt die \emph{ActivityElement} Modellklasse eine statische \emph{HashMap}. Jedem \emph{Verb} wird dadurch ein Satz in Form eines \emph{Strings} zugeordnet. Der von der \emph{ListView} verwendete Adapter bildet aus den einzelnen Feldern einer Activity einen Satz, den der Nutzer letztendlich zu Gesicht bekommt.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/implement/activitystream_ressource}
	\caption{Die ActivityStream Ressource nach \cite{Suntrup2012}.}
	\label{pic:activitystreamressource}
\end{figure}

\section{Wiederverwendung von Code - Ein Layout für verschiedene Fragments}
\label{sec:gridlayout}
Das Layout für \emph{Friends}/\emph{Follower} eines \emph{Users}, sowie die Liste der bei \emph{ginkgo} registrierten Events, soll konsistent sein sodass der Nutzer sich möglichst schnell zurecht findet. Dafür wird eine \emph{GridView} verwendet, die die einzelnen Elemente zweidimensional verteilt. Um gleichzeitig Programmcode zu sparen und die Übersichtlichkeit zu erhöhen wurde die abstrakte Klasse \emph{AGridFragment} entworfen. Sie implementiert Methoden, die für alle \emph{Unterklassen} identisch sind und schreibt vor, welche Methoden von dem Entwickler zu implementieren sind. 

Um eine neue Subklasse des \emph{AGridFragment} zu erstellen sind folgende Schritte notwendig:
\begin{enumerate}
	\item{Eine \emph{ArrayList} der anzuzeigenden Elemente (Beispiel: \emph{Event})}
	
	\item \textbf{String setJsonUrl()}
	
	Die \ac{URL} der zu ladenden Ressource muss in dieser Methode zurückgegeben werden. Die Oberklasse kümmert sich um das Herunterladen des \ac{JSON} Paketes. 
	
	\item \textbf{int setParseMode()}
	
	Je nach heruntergeladener Ressource muss eine andere Methode zum Parsen des \ac{JSON} Pakets verwendet werden. Die möglichen Modi werden als statische \emph{Integer} Variablen in der Oberklasse angeboten. 
	
	\item \textbf{void setContent(ArrayList list)}
	
	Es werden dem jeweiligen Fragment die geparsten Objekte übergeben. Diese müssen im Hauptspeicher gesichert werden.
	
	\item \textbf{ListAdapter setAdapter()}
	
	Diese Methode erwartet ein Objekt der Klasse ListAdapter, die eine Liste der anzuzeigenden Objekte enthält und beschreibt wie sie angezeigt werden sollen.
	
	\item \textbf{void createItemClickListener()}
	
	In der \emph{createItemClickListener} Methode wird definiert, was bei der Interaktion mit einem Element passieren soll.
	
	\item \textbf{void getIcons()}
	
	Die jeweiligen Icons der Ressource sollen heruntergeladen werden.
	
\end{enumerate}

Beispiele dieser Implementierung sind unter Abbildung \ref{pic:impfollowers} und Abbildung \ref{pic:impeventlist} zu sehen.

\section{Activity als Dialog}
\label{sec:dialog}
Um das Senden von Ressourcen an die \ac{API} optisch zu verdeutlichen, werden dafür \emph{Activitys} in Form eines Android \emph{Dialogs} verwendet. Die neue \emph{Activity}, die üblicherweise kleiner als der Bildschirm ist, wird über der aktuellen \emph{Activity} angezeigt (siehe \ref{pic:micropost}). Dieser optische Effekt wird bei allen Funktionen der Applikation verwendet werden, die Ressourcen an die \ac{API} schicken. Dadurch soll dem Nutzer deutlich werden, dass seine folgende Aktion durch das Abschicken öffentlich wird. Die Implementierung eines \emph{Dialogs} wird am Beispiel der \emph{Post Status} Funktion verdeutlicht.

Durch die Interaktion mit dem \emph{Post Status} Feld innerhalb der \emph{ActionBar} (siehe \ref{sec:actionbar}) wird die \emph{MicropostActivity} gestartet. 
Über die \emph{EditText View} kann der Nutzer einen 140 Zeichen langen Text verfassen, der über den \emph{Publish} Button versendet wird. Dafür wird die \emph{postStatus(String message)} Methode der JsonHelper Klasse mit dem jeweiligen Text aufgerufen. Anschließend wird der Text durch die statische \emph{stringToMicropost(String message)} der \emph{JsonParser} Klasse serialisiert und über die \emph{PostTask} Klasse an die \ac{API} versendet. Als letztes wird über die \emph{finish()} Methode die \emph{MicropostActivity} geschlossen und der Nutzer kann dort weitermachen, wo er aufgehört hat.

\section{Probleme}
In diesem Abschnitt werden die Probleme und deren Lösungen beschrieben, die während der Implementierung zustande kamen.

\subsection{Deserialiserung von HashMaps mit Gson}
Die \emph{Deserialisierung} durch \emph{Gson} von Ressourcen, die weiterführenden Links beinhalten, die in HashMaps gespeichert werden sollen\footnote{Ähnlich wie die \emph{Entry Points} der \ac{API} (siehe \ref{sec:api}).}, führt zur Laufzeit zu einem Fehler, der die Applikation zum Absturz bringt. Um dieses Verhalten zu umgehen, wurden die \emph{HashMaps} in den jeweiligen Modellklassen als \emph{transient} markiert. Dadurch werden diese Variablen bei der \emph{Deserialiserung} durch \emph{Gson} nicht gesetzt.

Um im Nachhinein die \emph{HashMap} mit den jeweiligen Links zu füllen, muss also auf die Hilfe dieser Library verzichtet und die Felder durch die Hilfe der Klassen \emph{org.json.JSONObject} und \emph{org.json.JSONArray} ausgelesen werden.

\subsection{Element einer GridView hat zur Laufzeit eine falsche Größe}
Bei der Darstellung der Elemente innerhalb der Subklassen von \emph{AGridFragment} (siehe \ref{sec:gridlayout}) wurde auf ein übersichtliches Layout geachtet, das gleichzeitig möglichst viele Informationen beinhalten soll. Obwohl das Layout in einer \emph{XML} Datei beschrieben war, wurden die Elemente zur Laufzeit nicht skaliert. Dadurch entstanden unnatürliche Proportionen. 

Um dieses Problem zu umgehen, musste die Größe der View innerhalb des jeweiligen \emph{Adapters} durch die Methode \emph{setLayoutParams} angepasst werden. Die Größenverhältnisse werden dadurch zur Laufzeit überschrieben, sodass die Elemente korrekt angezeigt werden.

\subsection{Verschachtelte JSON Ressourcen}
Das \graffito{Theorie} Herunterladen und \emph{Deserialisieren} von verschachtelten \ac{JSON} Ressourcen hat sich unter der verwendeten Architektur als schwierig erwiesen. Die Klasse \emph{JsonHelper} weiß während einer \emph{GET} Anfrage nicht, welche Ressource heruntergeladen wird. Also wird das \ac{JSON} Paket dem Aufrufer übergeben, sodass dieser die richtige Methode zur \emph{Deserialisierung} ausführen lässt. Bei einer einzigen Anfrage ist stellt das kein Problem dar, da eindeutig ist, um welche Ressource es sich dabei handelt. Sobald jedoch weitere Anfragen an die \ac{API} gestellt werden, wird das \emph{Fragment} bzw. die \emph{Activity} dieselbe Methode zur \emph{Deserialisierung} aufrufen, wie bei dem ersten \ac{JSON} Paket. Dadurch wird das daraus entstehende \ac{JSON} Paket falsch \emph{deserialisiert}, das dadurch entstandene Objekt unbrauchbar und das Programm stürzt ab. 

Das Herunterladen von verschachtelten \ac{JSON} Paketen kann in den meisten Fällen durch eine Option innerhalb der \ac{URL} umgangen werden (siehe Abschnitt \ref{sec:apiaufrufimp}), sodass alle Aufrufe, bis auf einen durch die verwendete Architektur problemlos durchgeführt werden können.

Um \graffito{Problem} alle \emph{User} anzeigen zu können, mit denen der Nutzer private Nachrichten geschrieben hat, muss die \emph{Conversation} Collection Ressource heruntergeladen werden. Eine \emph{Collection} beinhaltet einen weiterführenden Link zu dem Profil des Gesprächspartners und zu der \emph{Message} Collection, die die Nachrichten beinhaltet. Die Spezifikation einer \emph{Conversation} Ressource lässt das Einbinden einer \emph{User} Ressource innerhalb eines \ac{JSON} Paketes jedoch nicht zu. Demnach muss das \emph{ConversationPartnerFragment} zwei Anfragen an die \ac{API} stellen, sodass die jeweiligen \emph{User} innerhalb einer \emph{GridView} angezeigt werden können.

Aus \graffito{Lösung}diesem Problem heraus ist die \emph{getConversationPartners} Methode der \emph{JsonHelper} Klasse entstanden. Anstatt das \ac{JSON} Paket aus der Anfrage dem Aufrufer zu übergeben, kümmert sie sich selbst um die Deserialisierung, indem sie die \emph{parseConversationList()} Methode des \emph{JsonParsers} aufruft. Diese erzeugt eine \emph{ArrayList} des \emph{Conversation} Typs. Daraufhin wird für jede \emph{Conversation} eine Anfrage an die \emph{API} gestellt, die den jeweiligen \emph{User} innerhalb des \emph{Conversation} Objekts speichert. Da alle Anfragen asynchron laufen, muss verhindert werden, dass der Nutzer mit dem \ac{UI} interagiert bis jedes Objekt vollständig geladen ist. Dafür wird ein \emph{ProgressDialog} [\cite{Androidd}] verwendet, der erst geschlossen wird, sobald dies der Fall ist.

\subsection{Geplante aber nicht implementierte Features}
Da \emph{ginkgo} während dieser Implementierungsphase weder die Möglichkeit bot Veröffentlichungen zu wissenschaftlichen Veranstaltungen anzusehen, noch ein \emph{Check-in} zu Events möglich ist, wird auf diese Features verzichtet.

\section{Screenshots der fertigen Applikation}
In diesem Abschnitt werden Screenshots von \emph{ginkgo mobile} präsentiert.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/implement/logint}
	\caption{In der \emph{LoginActivity} werden die Kontodaten eingegeben.}
\end{figure}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/implement/dashboardt}
	\caption{Das Dashboard wird angezeigt, nachdem der Nutzer sich authentifiziert hat.}
\end{figure}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/implement/profilet}
	\caption{Das \emph{UserFragment} zeigt Informationen zu dem jeweiligen Nutzer an.}
\end{figure}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/implement/followerst}
	\caption{Die \emph{Friends} und \emph{Follower} werden innerhalb eines \emph{ViewPagers} angezeigt.}
	\label{pic:impfollowers}
\end{figure}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/implement/eventt}
	\caption{Informationen zu einem Event werden im \emph{EventFragment} angezeigt.}
\end{figure}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/implement/eventlistt}
	\caption{Das \emph{EventlistFragment} zeigt alle bei ginkgo registrierten Events an.}
	\label{pic:impeventlist}
\end{figure}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{__pics/implement/micropostt}
	\caption{Activity in Form eines Dialog -  Ein Microposts wird innerhalb einer \emph{Activity} in Form eines \emph{Dialogs} verfasst.}
	\label{pic:micropost}
\end{figure}




