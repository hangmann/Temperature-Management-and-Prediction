%!TEX root = /Users/nphs/Dropbox/0-Bachelor/2012-BA-Cioran/02-Arbeit/BA-Cioran.tex
\chapter{Technisches Rahmenwerk}
\label{ch:technisch}
Dieses Kapitel befasst sich mit dem Betriebssystem Android. In Abschnitt \ref{sec:android} werden die einzelnen Komponenten einer Android Applikation gezeigt, die Systemarchitektur beschrieben und die Vorteile von Android 3 aufgelistet. Im Abschnitt \ref{sec:umgebung} wird die Entwicklungsumgebung samt der verwendeten Technologien und Libraries aufgelistet.
\label{ch:technischesrahmenwerk}
\section{Android}
\label{sec:android}
	Android [\cite{Google}] ist eine Sammlung von Software die ein quelloffenes, auf Linux basierendes Betriebssystem, Middleware und eine Anzahl an Standard Applikationen umfasst. Ursprünglich wurde es von der \emph{Open Handset Alliance} [\cite{Alliance}], welche unter anderen von Google gegründet wurde, als Plattform für mobile Endgeräte konzipiert. Nach \cite{Arno2010} lässt sich Android verhältnismäßig leicht auch auf andere Gerätetypen portieren, sodass Android Anwendungen auf Smartphones, Netbooks oder Auto-Infotainment laufen können. Die Systemarchitektur ist dabei auf jedem System identisch (siehe Abbildung \ref{pic:androidarch}). Eigene Applikationen können in JAVA geschrieben werden. Nachdem der Quellcode kompiliert wurde, transformiert das im Android \ac{SDK} enthaltene Programm dx den Java-Bytecode in Dalvik-Bytecode um. Für jede gestartete Anwendung wird ein eigener Betriebssystemprozess mit einer \ac{DVM} gestartet, die auf der quelloffenen \ac{JVM} Apache Harmony basiert [\cite{Arno2010}]. Die \ac{DVM} führt den Dalvik Bytecode aus und bietet gleichzeitig Schutz vor anderen Anwendungen, da jedes Programm isoliert in ihrer eigenen virtuellen Maschine läuft. Die \ac{JVM} kommt nach \cite{Arno2010} aus zwei Gründen bei Android nicht zum Einsatz: zum einen unterstützt dessen virtuelle Prozessorarchitektur keine Register, sodass die Möglichkeiten moderner Prozessoren nicht ausgenutzt würden. Zum anderen hat diese Entscheidung auch rechtliche Hintergründe, da die \ac{JVM} und Java-Bytecode lizenzrechtlich geschützt sind. Durch den Dalvik-Bytecode und der \ac{DVM} müssen keine Gebühren an die Firma Oracle, dem Herausgeber der \ac{JVM}, gezahlt werden.
	
	Im Folgenden wird auf die einzelnen Schichten der Systemarchitektur eingegangen (siehe Abbildung \ref{pic:androidarch}). Nähere Details lassen sich unter \cite{Googlea} und \cite{Arno2010} nachlesen.
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{__pics/android/system-architecture}
		\caption{Die Android Architektur nach \cite{Googlea}}
		\label{pic:androidarch}	
	\end{figure}
	\begin{itemize}
		\item \textbf{Applications:} In dieser Schicht befinden sich alle Android Anwendungen. Diverse Applikationen wie das Kontaktbuch werden vom Betriebssystem mitgeliefert und weitere lassen sich zum Beispiel über den Android Market einspielen. Der Austausch zwischen Mensch und Maschine findet auf dieser Ebene statt [\cite{Arno2010}].
		\item \textbf{Application Framework:} Diese Schicht bietet den Applikationen einen vereinfachten Zugriff auf die Hardwarekomponenten des Endgerätes. Dadurch lassen sich beispielsweise der aktuelle Standort über GPS abrufen und Hintergrundprozesse starten.
		\item \textbf{Libraries:} Es existieren viele C\textbackslash C++ Bibliotheken, die diverse Funktionen der Darstellung von Grafiken über OpenGL ermöglichen bis über das Datenbanksystem SQLite, um Daten persistent auf dem Endgerät zu speichern.
		\item \textbf{Android Runtime:} Für jede gestartete Anwendung wird ein Betriebssystemprozess gestartet und in diesem eine eigene \ac{DVM} [\cite{Arno2010}].
	\end{itemize}
	
	\subsection{Android Komponenten}
	\label{sec:androidprog}
	Ein Android Programm ist im wesentlichen eine Ansammlung aus vier verschiedenen Komponenten die alle einem bestimmten Zweck dienen. Das Verhalten einer Applikation wird durch das Zusammenspiel ihrer Komponenten bestimmt [\cite{Googled}]. Im Nachfolgenden werden die Komponenten nach \cite{Googled} erläutert.
	\begin{itemize}
		\item \textbf{Activity}
		
		Eine Activity dient der Darstellung und Kontrolle von verschiedenen Views wie Buttons, Bildern oder Text. Views lassen sich durch \emph{ViewGroups}, wie zum Beispiel das LinearLayout, auf dem Bildschirm ordnen. Um einer Activity verschiedene Views hinzuzufügen, hat der Entwickler die Möglichkeit das Layout entweder statisch per XML zu definieren oder direkt im Programmcod. Dies eignet sich für dynamisch ändernde Views. Statische Layouts sollten  per XML eingebunden werden, da diese Methode die Darstellung von den Programmabläufen und Layout trennt. Des Weiteren bietet sie eine zentrale Anlaufstelle für Änderungen am \ac{UI}, sodass dem Entwickler die Suche im Programmcode erspart bleibt. 
		\item \textbf{Service}
		
		Durch einen Service lassen sich lang andauernde Hintergrundoperationen realisieren. Er wird meist durch andere Komponenten gestartet und bietet kein \ac{UI}. Er kann einserseits an die ihn aufrufende Komponente gebunden werden, sodass der Service stoppt, sobald die Komponente beendet wird. Andererseits kann er als eigener Prozess gestartet werden. Dadurch wird der Service nicht automatisch beendet wenn die Komponente gestoppt wird.
		\item \textbf{Content Providers}
		
		Da jede Applikation in ihrer eigenen \ac{DVM} gestartet wird, können Applikationen eigentlich keine Daten untereinander austauschen. Falls dieses Verhalten für bestimmte Daten nicht gewünscht ist, lassen sich Content Providers einrichten, sodass andere Applikationen Daten der eigenen Applikation verwenden können.
		\item \textbf{Broadcast Receivers} 
		
		Android versendet bei bestimmten Systemereignissen, wie z.B. einem kritischen Akkustand, einen sogenannten \emph{Broadcast Intent}. Jede Applikation kann durch die Implementierung von Broadcast Receivers Broadcast Intents empfangen und entsprechend darauf reagieren, indem zum Beispiel eine eigene Activity gestartet wird.
	\end{itemize}
	
	\subsection{Android 3 - Honeycomb}
	\label{sec:android3}
	 Die Open Handset Alliance hat Android 3 entwickelt, welches speziell für Tablets konzipiert wurde [\cite{Googleb}]. Sie bietet sowohl eine für Tablets angepasste Benutzeroberfläche an als auch neue Funktionen für Benutzer und Entwickler. Darunter gehören zum Beispiel die \emph{Action -} und die \emph{Systembar}. Die Actionbar befindet sich am oberen Abschnitt des Bildschirms und passt sich kontextsensitiv auf die Interaktionen des Nutzers an [\cite{Googlec}]. Ihre Funktionen werden dabei innerhalb der jeweiligen Activity implementiert. Die \emph{System Bar} hingegen befindet sich im unteren Abschnitt des Bildschirms und bietet Funktionen zur Navigation und Systeminformationen an[\cite{Googlec}]. 
	
	Eine weitere Neuerung ist die Einführung von \emph{Fragments}. Eine Activity kann mehrere Fragments beinhalten, die jeweils einen Teil des \ac{UI} ausmachen (siehe Abbildung \ref{pic:fragments}). Durch Interaktionen mit dem Nutzer kann die Activity \emph{Fragments} dynamisch austauschen. Darüber hinaus lassen sie sich wiederverwenden, sodass ihre Funktionen an verschiedenen Stellen im Programm angeboten werden können [\cite{Googlec}].
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{__pics/android/fragments}
		\caption{Eine Activity kann mehrere Fragments beinhalten [\cite{Googlec}]}
		\label{pic:fragments}	
	\end{figure}

	\section{Die Entwicklungsumgebung und spezifische Technologien}
	\label{sec:umgebung}
	
	\subsection{Eclipse}
	Zur Entwicklung von Applikationen für Android werden diverse Tools, wie zum Beispiel ein Compiler, benötigt, die zusammen kostenlos als \ac{SDK} angeboten werden. Der Entwicklungsprozess gestaltet sich durch die Benutzung des Eclipse Plugins \ac{ADT} einfacher als per Kommdandozeile, da dies der \ac{IDE} Eclipse alle nötigen Funktionen zur Entwicklung eines Programms zur Verfügung stellt und automatisiert. Um diesen Vorteil zu nutzen wird zur Programmierung Eclipse verwendet. Zusätzlich bringt das \ac{SDK} das \ac{AVD} Tool mit sich, sodass die Applikation auf einem PC emuliert werden kann.
	\begin{leftbar} \textbf{Designentscheidung}
	Um \emph{ginkgo mobile} ausführen zu können, wird auf dem Endgerät mindestens die Android Version 3.0 vorausgesetzt, da diese speziell an die Bedürfnisse der Tablet Nutzer angepasst ist. 
	\end{leftbar}
	
%	Dieser Abschnitt gibt einen Überblick über die von der \ac{API} vorgegeben Technologien. 
	\subsection{OAuth 2.0}
	\label{sec:oauth}
	Durch OAuth wird sowohl die Applikation als auch der Nutzer gegenüber dem Server identifiziert. Dadurch wird sichergestellt, dass nur authorisierte Programme Zugriff auf die \emph{ginkgo} \ac{API} (siehe \ref{sec:api}) haben. Zusätzlich wird der Nutzer identifiziert, sodass nur Daten abgefragt und angezeigt werden, die der Nutzer sehen darf. 
	
	Um auf die \ac{API} zugreifen zu können, muss die Applikation bei \emph{ginkgo} registriert werden. Dadurch werden dem Programm eine \emph{Client id} und ein \emph{Client secret} zugewiesen. Die darauf folgende Authentifizierung wird in drei Schritte unterteilt (siehe \ref{pic:oauth}) und über einen Browser durchgeführt. Der erste Schritt ist die \emph{User authentication}. Dadurch wird eine von der \ac{API} angebotenen Webseite innerhalb der Applikation aufgerufen, in der der Nutzer seinen Benutzernamen und Passwort eingeben kann. Durch einen erfolgreichen Login beginnt die \emph{Application authorization} Phase. Der Nutzer wird dazu aufgefordert, der jeweiligen Applikation den Zugriff auf seine Daten zu gewähren. Durch einen \ac{HTTP} Redirect wird daraufhin der Applikation ein \emph{Authorization Code} übermittelt. Diese wird durch eine weitere Anfrage in der \emph{Application authentication} Phase in ein \emph{Access Token} ausgetauscht. Das \emph{Access Token} muss von der Applikation gespeichert und bei jeder Anfrage an die \ac{API} mitgesendet werden.
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{__pics/diagramme/oauth_blockd}
		\caption{Die Authentifizierung wird in drei Phasen aufgeteilt}
		\label{pic:oauth}	
	\end{figure}
	 
	\subsection{Die ginkgo \ac{API} und \ac{JSON}}
	\label{sec:api}
	Um an die von \emph{ginkgo} gespeicherten Informationen und Daten Zugriff zu bekommen, bedarf es an einer Schnittstelle zwischen Applikation und Server.
	
	 Diese Schnittstelle wird parallel zu dieser Bachelorarbeit von Christoph Suntrup unter dem \ac{REST}-Architekturstil umgesetzt [\cite{Suntrup2012}]. Dabei werden Daten von \emph{ginkgo} wie Events und deren \emph{Follower} als Ressourcen betrachtet. Auf Ressourcen lassen sich ein Satz an Operationen ausführen, die durch die \ac{HTTP}-Spezifikationen festgelegt wurden [\cite{Suntrup2012}]. 
	\begin{itemize}
		\item Über die \textbf{GET}-Methode lassen sich Ressourcen vom Server abfragen.
		\item Durch ein \textbf{POST} lassen sich neue Ressourcen auf dem Server anlegen.
		\item Durch \textbf{PUT} lassen sich bereits vorhandene Ressourcen editieren.
		\item \textbf{DELETE} löscht die jeweilige Ressource.
	\end{itemize}
Um an die einzelnen Ressourcen ranzukommen, bietet die \ac{API} eine Liste an \emph{Entrypoints} unter einer festen \emph{URL} an. Dazu gehören zum Beispiel die Liste aller bei \emph{ginkgo} registrierten Events. Durch die \emph{Entrypoints} ist eine Navigation durch alle für den Nutzer sichtbaren Daten möglich, da eine Ressource andere beinhalten kann.
	
	 	Bei der Übertragung der Ressourcen wird die \ac{JSON}\footnote{JSON ist ein Programmiersprachen unabhängiges Datenaustauschformat, das für Menschen leicht zu lesen und für Computer leicht zu parsen ist [\cite{JSON}].} als Repräsentationsformat verwendet. Eine Liste von Events von der \ac{API} an die Applikation ist also ein \ac{JSON} Paket, das die einzelnen Events beinhaltet. Durch die von JAVA mitgelieferten Klassen lassen sich diese Informationen aus den JSON Paketen parsen und dadurch weiterverwenden. Das Repräsentationsformat für die \emph{POST} Methode ist demnach dasselbe. Bei der Erstellung eines neuen Events auf dem Server, muss die Applikation die notwendigen Daten im \ac{JSON} Format an den Server senden. 
	\begin{figure}[h]
		\begin{center}
		\includegraphics[width=6cm]{__pics/diagramme/abstrakt_get_seqd}
		\caption{Um eine Ressource abzufragen, sendet die Applikation ein GET an die von der \ac{API} definierten \ac{URL}. Der Server liest die Ressource ein und transformiert sie in das \ac{JSON} Repräsentationsformat. Anschließend wird diese Information an die Applikation zurückgeschickt. Das \ac{JSON} Paket wird daraufhin von der Applikation gelesen und weiterverarbeitet.}
		\end{center}
		\label{pic:abstraktget}	
	\end{figure}
	
	\subsection{Verwendete Libraries}
	Zu den von Android bereitgestellten Klassen werden zusätzliche Libraries zur Implementierung verschiedener Funktionen verwendet. Im Folgenden werden diese vorgestellt.
	\subsubsection{Android Support Package}
	\label{sec:supportpackage}
	Das \emph{Android Support Package} [\cite{Androida}] beinhaltet die Klasse \emph{ViewPager}, die eine kompakte Darstellung an Informationen bietet. Durch das horizontale Scrollen lassen sich Informationen darstellen, die sonst über den Bildschirmrand hinausragen würden. Dieses \ac{UI} pattern findet sich bereits in vielen Google Apps [\cite{Bray2011}]. Der Titel der aktuell angezeigten Seite des \emph{ViewPagers} wird durch die Funktionen der \emph{ViewPagerIndicator} [\cite{Wharton2011}] Bibliothek realisiert.   
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{__pics/MarketSwipe}
		\caption{Ein ViewPager innerhalb des \emph{Android Markt} [\cite{Bray2011}]}
		\label{pic:marketswipe}	
	\end{figure}
	\begin{leftbar}
		Um einen ViewPager innerhalb eines Fragments verwenden zu können, muss die \emph{Fragment} Klasse des \emph{Android Support Package} anstelle der von Android bereitgestellten \emph{Fragment} Klasse verwendet werden. Durch dieses Vorgehen können Fragments auch auf Android 2 Geräten dargestellt werden.
	\end{leftbar}
	
	\subsubsection{Gson}
	\label{sec:gson}
	Bei der \emph{Deserialisierung} werden aus Datenstrukturen, wie \ac{JSON} Pakete, Java Objekte erzeugt. Dadurch lässt sich aus einer Antwort der API ein neues Objekt einer bestimmten Klasse erstellen. Bei einem in Form einer Klasse vorhandenen Modell des zu erstellenden Objekts, lässt sich dieser Vorgang durch \emph{Gson} automatisieren [\cite{Google2011a}]. So können Objekte direkt zur Laufzeit erstellt werden ohne dass der Entwickler sich um das Setzen der einzelnen Attribute kümmern muss. Zusätzlich bietet Gson die Möglichkeit, vorhandene Java Objekte auf \ac{JSON} Pakete abzubilden. Dieser Vorgang wird als \emph{Serialisierung} bezeichnet.  
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{__pics/diagramme/gson_blockd}
		\caption{\textbf{Deserialisierung:} Aus einer \emph{Modell} Klasse und einem \ac{JSON} erstellt \emph{Gson} ein neues Java Objekt vom Typ \emph{Modell}}
		\label{pic:deserialisierung}	
 	\end{figure}

	\subsubsection{Google Maps}
	\label{sec:googlemaps}
	Zur Darstellung der Events auf einer Landkarte wird die Google Maps API verwendet.
	%Die für \emph{ginkgo mobile} notwendigen Informationen werden von der \ac{API} als \ac{JSON} Pakete geliefert.
	% Gson übernimmt jedoch sowohl die Deserialisierung als auch die Serialisierung [\cite{Google2011a}]. 